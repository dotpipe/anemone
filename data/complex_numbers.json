{
  "complex_number": [
    {
      "gloss": "a number with a real part and an imaginary part",
      "formula": "a + b*i",
      "exec": "lambda a, b: complex(a, b)"
    }
  ],

  "real_part": [
    {
      "gloss": "the real component of a complex number",
      "formula": "Re(a + b*i) = a",
      "exec": "lambda z: z.real"
    }
  ],

  "imaginary_part": [
    {
      "gloss": "the imaginary component of a complex number",
      "formula": "Im(a + b*i) = b",
      "exec": "lambda z: z.imag"
    }
  ],

  "complex_conjugate": [
    {
      "gloss": "a complex number with the sign of the imaginary part reversed",
      "formula": "conj(a + b*i) = a - b*i",
      "exec": "lambda z: complex(z.real, -z.imag)"
    }
  ],

  "magnitude": [
    {
      "gloss": "the distance of a complex number from the origin",
      "formula": "|z| = (a^2 + b^2)^(1/2)",
      "exec": "lambda z: (z.real**2 + z.imag**2)**0.5"
    }
  ],

  "argument": [
    {
      "gloss": "the angle a complex number makes with the positive real axis",
      "formula": "arg(z) = arctan(b / a)",
      "exec": "lambda math, z: math.atan2(z.imag, z.real)"
    }
  ],

  "addition": [
    {
      "gloss": "adding two complex numbers componentwise",
      "formula": "(a + b*i) + (c + d*i) = (a + c) + (b + d)*i",
      "exec": "lambda z1, z2: z1 + z2"
    }
  ],

  "subtraction": [
    {
      "gloss": "subtracting two complex numbers componentwise",
      "formula": "(a + b*i) - (c + d*i) = (a - c) + (b - d)*i",
      "exec": "lambda z1, z2: z1 - z2"
    }
  ],

  "multiplication": [
    {
      "gloss": "multiplying two complex numbers using distributive property",
      "formula": "(a + b*i)(c + d*i) = (ac - bd) + (ad + bc)*i",
      "exec": "lambda z1, z2: z1 * z2"
    }
  ],

  "division": [
    {
      "gloss": "dividing two complex numbers using conjugates",
      "formula": "(a + b*i) / (c + d*i) = ((a + b*i)(c - d*i)) / (c^2 + d^2)",
      "exec": "lambda z1, z2: z1 / z2"
    }
  ],

  "polar_form": [
    {
      "gloss": "representing a complex number using magnitude and angle",
      "formula": "z = r*(cos(theta) + i*sin(theta))",
      "exec": "lambda math, r, theta: complex(r*math.cos(theta), r*math.sin(theta))"
    }
  ],

  "euler_formula": [
    {
      "gloss": "the exponential representation of complex numbers",
      "formula": "e^(i*theta) = cos(theta) + i*sin(theta)",
      "exec": "lambda math, theta: complex(math.cos(theta), math.sin(theta))"
    }
  ],

  "power_polar": [
    {
      "gloss": "raising a complex number to an integer power using polar form",
      "formula": "z^n = r^n * (cos(n*theta) + i*sin(n*theta))",
      "exec": "lambda math, r, theta, n: complex((r**n)*math.cos(n*theta), (r**n)*math.sin(n*theta))"
    }
  ],

  "root_polar": [
    {
      "gloss": "the nth roots of a complex number using polar form",
      "formula": "z^(1/n) = r^(1/n) * (cos((theta + 2*pi*k)/n) + i*sin((theta + 2*pi*k)/n))",
      "exec": "lambda math, r, theta, n, k: complex((r**(1.0/n))*math.cos((theta + 2*math.pi*k)/n), (r**(1.0/n))*math.sin((theta + 2*math.pi*k)/n))"
    }
  ]
}
