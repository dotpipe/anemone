{
  "simple_interest": [
    {
      "gloss": "interest calculated only on the original principal",
      "formula": "I = P * r * t",
      "exec": "lambda P, r, t: P * r * t"
    }
  ],

  "compound_interest": [
    {
      "gloss": "interest calculated on the principal and accumulated interest",
      "formula": "A = P * (1 + r/n)^(n*t)",
      "exec": "lambda P, r, n, t: P * ((1 + r/n)**(n*t))"
    }
  ],

  "future_value": [
    {
      "gloss": "the value of a present amount after interest accumulates",
      "formula": "FV = PV * (1 + r)^n",
      "exec": "lambda PV, r, n: PV * ((1 + r)**n)"
    }
  ],

  "present_value": [
    {
      "gloss": "the current value of a future payment",
      "formula": "PV = FV / (1 + r)^n",
      "exec": "lambda FV, r, n: FV / ((1 + r)**n)"
    }
  ],

  "discount_factor": [
    {
      "gloss": "the factor used to convert future value into present value",
      "formula": "DF = 1 / (1 + r)^n",
      "exec": "lambda r, n: 1 / ((1 + r)**n)"
    }
  ],

  "annuity_future_value": [
    {
      "gloss": "the future value of equal payments made at regular intervals",
      "formula": "FV = PMT * ((1 + r)^n - 1) / r",
      "exec": "lambda PMT, r, n: PMT * (((1 + r)**n - 1) / r)"
    }
  ],

  "annuity_present_value": [
    {
      "gloss": "the present value of equal payments made at regular intervals",
      "formula": "PV = PMT * (1 - (1 + r)^(-n)) / r",
      "exec": "lambda PMT, r, n: PMT * (1 - (1 + r)**(-n)) / r"
    }
  ],

  "loan_payment": [
    {
      "gloss": "the fixed payment required to amortize a loan",
      "formula": "PMT = P * r * (1 + r)^n / ((1 + r)^n - 1)",
      "exec": "lambda P, r, n: P * r * ((1 + r)**n) / (((1 + r)**n) - 1)"
    }
  ],

  "amortization_balance": [
    {
      "gloss": "the remaining balance on a loan after k payments",
      "formula": "B = P*(1+r)^k - PMT*((1+r)^k - 1)/r",
      "exec": "lambda P, r, k, PMT: P*((1+r)**k) - PMT*(((1+r)**k - 1)/r)"
    }
  ],

  "return_rate": [
    {
      "gloss": "the percentage gain or loss on an investment",
      "formula": "R = (V_final - V_initial) / V_initial",
      "exec": "lambda V_final, V_initial: (V_final - V_initial) / V_initial"
    }
  ],

  "expected_return": [
    {
      "gloss": "the weighted average return of possible outcomes",
      "formula": "E(R) = sum(p_i * r_i)",
      "exec": "lambda ps, rs: sum(ps[i] * rs[i] for i in range(len(ps)))"
    }
  ],

  "portfolio_return": [
    {
      "gloss": "the weighted average return of assets in a portfolio",
      "formula": "R_p = sum(w_i * r_i)",
      "exec": "lambda ws, rs: sum(ws[i] * rs[i] for i in range(len(ws)))"
    }
  ],

  "portfolio_variance": [
    {
      "gloss": "the variance of a two asset portfolio",
      "formula": "Var = w1^2*s1^2 + w2^2*s2^2 + 2*w1*w2*cov12",
      "exec": "lambda w1, w2, s1, s2, cov12: w1**2 * s1**2 + w2**2 * s2**2 + 2*w1*w2*cov12"
    }
  ],

  "capital_asset_pricing_model": [
    {
      "gloss": "the expected return of an asset based on risk",
      "formula": "E(R) = Rf + beta*(Rm - Rf)",
      "exec": "lambda Rf, beta, Rm: Rf + beta*(Rm - Rf)"
    }
  ],

  "sharpe_ratio": [
    {
      "gloss": "a measure of risk adjusted return",
      "formula": "Sharpe = (R_p - Rf) / sd_p",
      "exec": "lambda Rp, Rf, sd: (Rp - Rf) / sd"
    }
  ],

  "beta": [
    {
      "gloss": "a measure of an asset's sensitivity to market movements",
      "formula": "beta = cov(asset, market) / var(market)",
      "exec": "lambda cov, var_m: cov / var_m"
    }
  ],

  "bond_price": [
    {
      "gloss": "the present value of a bond's coupon payments and face value",
      "formula": "P = sum(C/(1+r)^t) + F/(1+r)^n",
      "exec": "lambda C, r, n, F: sum(C/((1+r)**t) for t in range(1, n+1)) + F/((1+r)**n)"
    }
  ],

  "bond_yield_to_maturity": [
    {
      "gloss": "the discount rate that sets the bond price equal to present value",
      "formula": "solve P = sum(C/(1+r)^t) + F/(1+r)^n",
      "exec": "lambda price, C, F, n: None"
    }
  ]
}
